### В каком порядке вызовутся кострукторы и в каком деструкторы
```cpp
struct Abase
{
    Abase()
    {
        std::cout<<"Abase()"<<std::endl;
    }
    ~Abase()
    {
        std::cout<<"~Abase()"<<std::endl;
    }
};

struct Bbase
{
    Bbase()
    {
        std::cout<<"Bbase()"<<std::endl;
    }
    ~Bbase()
    {
        std::cout<<"~Bbase()"<<std::endl;
    }
};

struct Afield
{
    Afield()
    {
        std::cout<<"Afield()"<<std::endl;
    }
    ~Afield()
    {
        std::cout<<"~Afield()"<<std::endl;
    }
};

struct Bfield
{
    Bfield()
    {
        std::cout<<"Bfield()"<<std::endl;
    }
    ~Bfield()
    {
        std::cout<<"~Bfield()"<<std::endl;
    }
};

struct Curent : Abase , Bbase
{
    Curent()
    {
        std::cout<<"Curent()"<<std::endl;
    }
    ~Curent()
    {
        std::cout<<"~Curent()"<<std::endl;
    }
    Afield a;
    Bfield b;
};

int main() {
    Curent cur;
}

```

#### Output
Сначала вызываются конструкторы наследников , после полей  , потом самого класса. Деструкторы в обратном порядке.
Abase()
Bbase()
Afield()
Bfield()
Curent()
~Curent()
~Bfield()
~Afield()
~Bbase()
~Abase()

### Для чего нужно ключевое слово explicit

Ключевое слово explicit используется для явного указания компилятору, что конструктор или оператор преобразования должны использоваться только в явных (explicit) преобразованиях типов, а не в неявных

```cpp
class Simple {
public:
    Simple() : a_(0), b_(0) {}
    Simple(int a) : a_(a), b_(0) {}
    Simple(int a, int b) : a_(a), b_(b) {}
    operator bool() const { return true; }
private:
    int a_, b_;
};

class SimpleExplicit {
public:
    explicit SimpleExplicit() : a_(0), b_(0) {}
    explicit SimpleExplicit(int a) : a_(a), b_(0) {}
    explicit SimpleExplicit(int a, int b) : a_(a), b_(b) {}
    explicit operator bool() const { return true; }
private:
    int a_, b_;
};

template <typename S>
void someFunc(const S& s) {
}

int main() {
    Simple s4 = {};
    someFunc<Simple>({});
    // SimpleExplicit se4 = {}; - COMPILE ERROR
    SimpleExplicit se4 = SimpleExplicit{};
    // someFunc<SimpleExplicit>({}); - COMPILE ERROR
    someFunc<SimpleExplicit>(SimpleExplicit{});

    Simple s5 = { 11 };
    someFunc<Simple>({ 11 });
    SimpleExplicit se5(11);
    // SimpleExplicit se5 = {11}; - COMPILE ERROR
    SimpleExplicit se5 = SimpleExplicit{ 11 };
    // someFunc<SimpleExplicit>({11}); - COMPILE ERROR
    someFunc<SimpleExplicit>(SimpleExplicit{ 11 });

    Simple s6 = { 11, 22 };
    someFunc<Simple>({ 11, 22 });
    // SimpleExplicit se6 = {11, 22}; - COMPILE ERROR
    SimpleExplicit se6 = SimpleExplicit{ 11, 22 };
    // someFunc<SimpleExplicit>({11, 22}); - COMPILE ERROR
    someFunc<SimpleExplicit>(SimpleExplicit{ 11, 22 });

    Simple s7{};
    bool b7 = s7;

    SimpleExplicit se7{};
    // bool be7 = se7; - COMPILE ERROR
    bool be7 = static_cast<bool>(se7);

}

```

### Процесс компиляции программы C++

#### 1) Препроцессинг

Препроцессор — это макро процессор, который преобразовывает вашу программу для дальнейшего компилирования. На данной стадии происходит происходит работа с препроцессорными директивами. Например, препроцессор добавляет хэдеры в код (#include), убирает комментирования, заменяет макросы (#define) их значениями, выбирает нужные куски кода в соответствии с условиями #if, #ifdef и #ifndef.


Хэдеры, включенные в программу с помощью директивы #include, рекурсивно проходят стадию препроцессинга и включаются в выпускаемый файл. Однако, каждый хэдер может быть открыт во время препроцессинга несколько раз, поэтому, обычно, используются специальные препроцессорные директивы, предохраняющие от циклической зависимости.


Получим препроцессированный код в выходной файл driver.ii (прошедшие через стадию препроцессинга C++ файлы имеют расширение .ii), используя флаг -E, который сообщает компилятору, что компилировать (об этом далее) файл не нужно, а только провести его препроцессинг)
```cpp
$ g++ -E driver.cpp -o driver.ii
```
#### 2) Компиляция

На данном шаге g++ выполняет свою главную задачу — компилирует, то есть преобразует полученный на прошлом шаге код без директив в ассемблерный код. Это промежуточный шаг между высокоуровневым языком и машинным (бинарным) кодом.


Ассемблерный код — это доступное для понимания человеком представление машинного кода.


Используя флаг -S, который сообщает компилятору остановиться после стадии компиляции, получим ассемблерный код в выходном файле driver.s:

```cpp
$ g++ -S driver.ii -o driver.s
```
#### 3) Ассемблирование

Так как x86 процессоры исполняют команды на бинарном коде, необходимо перевести ассемблерный код в машинный с помощью ассемблера.


Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в объектном файле.


Объектный файл — это созданный ассемблером промежуточный файл, хранящий кусок машинного кода. Этот кусок машинного кода, который еще не был связан вместе с другими кусками машинного кода в конечную выполняемую программу, называется объектным кодом.


Далее возможно сохранение данного объектного кода в статические библиотеки для того, чтобы не компилировать данный код снова.


Получим машинный код с помощью ассемблера (as) в выходной объектный файл driver.o:

```cpp
$ as driver.s -o driver.o
```
#### 4) Компоновка

Компоновщик (линкер) связывает все объектные файлы и статические библиотеки в единый исполняемый файл, который мы и сможем запустить в дальнейшем. Для того, чтобы понять как происходит связка, следует рассказать о таблице символов.


Таблица символов — это структура данных, создаваемая самим компилятором и хранящаяся в самих объектных файлах. Таблица символов хранит имена переменных, функций, классов, объектов и т.д., где каждому идентификатору (символу) соотносится его тип, область видимости. Также таблица символов хранит адреса ссылок на данные и процедуры в других объектных файлах.
Именно с помощью таблицы символов и хранящихся в них ссылок линкер будет способен в дальнейшем построить связи между данными среди множества других объектных файлов и создать единый исполняемый файл из них.
```cpp
$ g++ driver.o -o driver // также тут можно добавить и другие объектные файлы и библиотеки
```

#### 5) Загрузка

Последний этап, который предстоит пройти нашей программе — вызвать загрузчик для загрузки нашей программы в память. На данной стадии также возможна подгрузка динамических библиотек.

```cpp
$ ./driver 
```

### Зачем в макросах аргументы брать в скобки 

Для применения макроса с аргументами нужно указать имя макроса, за которым следует список аргументов, заключенных в скобки и разделенных запятыми.

```cpp
#define min(X, Y)  ((X) < (Y) ? (X) : (Y))
```
Работа максроса - подставление текста

Если передавать отрицательные числа то может сбиться порядок вычисления.

### Как исключить попадания header повторно в файлы

#ifdef и #ifndef
pragma once

### Как объявить 2 класса которые будут хранить указатели друг на друга 

```cpp
class B; // предварительная декларация
class A
{
    A *a;
}

class B
{
    B *b;
}

```

### Что будет если вызвать delete на nullptr , а на ноль.

Они сработают , но ничего не произойдёт.
nullptr - кастатится к bool но не к int;

### Зачем нужны virtual деструкторы 

```cpp
class A {
public:
    A() { std::cout << "A()" << std::endl; }
    ~A() { std::cout << "~A()" << std::endl; }
};

class B : public A {
public:
    B() { std::cout << "B()" << std::endl; }
    ~B() { std::cout << "~B()" << std::endl; }
};

class Av
{
public:
    Av() { std::cout << "A()" << std::endl; }
    virtual ~Av() { std::cout << "~A()" << std::endl; }
};

class Bv : public Av {
public:
    Bv() { std::cout << "B()" << std::endl; }
    ~Bv() { std::cout << "~B()" << std::endl; }
};

int main() {
    B b;
    // Output : A() B() ~B() ~A()

    A* pA = new B;
    delete pA;
    //Output : A() B() ~A()

    Av* pAv = new Bv;
    delete pAv;
    //Output : A() B() ~B() ~A()
    return 0;
}
```

Происходит так потому, что отныне для вызова деструктора используется позднее связывание, то есть при разрушении объекта берется указатель на класс, затем из таблицы виртуальных функций определяется адрес нужного нам деструктора, а это деструктор производного класса, который после своей работы, как и полагается, вызывает деструктор базового. Итог: объект разрушен, память освобождена.